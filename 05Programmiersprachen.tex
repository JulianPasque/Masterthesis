\chapter{Unterschiede zwischen C\# und Dart}
\label{chap:Programmiersprachen}

Nach den in Kapitel \ref{chap:CrossPlattformFrameworks} behandelten Unterschieden zwischen den Frameworks, wird in diesem Kapitel die Heterogenität zwischen den Hochsprachen \Csharp und Dart behandelt.  Durch den ähnlichen Stil und vergleichbare Syntax der beiden objektorientierten Programmiersprachen wird der Umstieg von Xamarin.Forms zu Flutter erleichtert.\footcite[Vgl. ][Abgerufen am \today]{Pedley2019}Alle Unterschiede zwischen den Programmiersprachen können innerhalb des Quelltextes der mobilen Anwendung vorkommen und müssen daher bei der Übersetzung von Apps berücksichtigt werden.

\section{Klassendesign}
In diesem Abschnitt sollen die sogenannten Klassen und Objekte der objektorientierten Programmierung (OOP) betrachtet werden, die sowohl in \Csharp als auch in Dart, allerdings mit vereinzelten Unterschieden bei der Realisierung, Verwendung finden. Die sogenannten Objekte werden in diesem Paradigma durch bestimmte,  charakteristische Merkmale beschrieben  die in der Klassendefinition festgelegt werden müssen. \footcite[Vgl.][S. 11f.]{Witte2013}

\subsection{Referenz- und Wertetypen}

Das von \Csharp verwendete .NET- Typsystem unterscheidet in Werte- und Referenztypen.  Der Unterschied zwischen beiden ist in der Allokation des Systemspeichers zu finden.  Eine Variable des Wertetyps enthält eine Instanz des Typs.  Dies unterscheidet sich von einer Variablen des Referenztyps, der eine Adresse der Speicherzellen des Typs enthält. \footcite[Vgl.][S. 155f.]{Kühnel2019} \Csharp bietet die folgenden Wertetypen,  ganzzahlig numerische Typen (Integer),  fließkomma numerische Typen (Float und Double),  Wahrheitswerte (Boolean) und ein Zeichen(Char).  Jeder Variablen dieser Typen muss immer einen zum Typ passender Wert zugewiesen sein.  Daraus folgt,  das zu jeder Zeit in einer Instanz des Typs Integer eine Zahl verwaltet werden muss. \footcite[Vgl. ][Abgerufen am \today]{MicrosoftValueTypes2020} Um die Bedingung dieser Wertpflicht zu umgehen,  gibt es in der Hochsprache \Csharp die sogenannte \glq nullable\grq{} Typen,  die neben den zulässigen Werten zusätzlich den Wert \glq null\grq{} akzeptieren. \footcite[Vgl.][S. 167]{Bayer2008} 


Die Programmiersprache Dart war bis zu der Version 2.12 \glq nicht Null sicher\grq . Da nicht gewährleistet war, das Typen einen entsprechenden Wert zu jeder Zeit 
repräsentieren mussten,  war zur Vermeidung von Laufzeitfehlern eine Null Prüfung, wie in Quelltext \ref{lst:DartNull} dargestellt, bei der Arbeit mit Variablen erforderlich.   

\lstinputlisting[label={lst:DartNull},caption={[Null-Sicherheit in Dart bis Version 2.12]{Null-Sicherheit in Dart 1.x\footcite[In Anlehnung an ][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartNull.Dart}

Im März 2021 hat\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} die Programmiersprache Dart den Support für Null-Sicherheit hinzugefügt,  diese gravierende Änderung für Softwareentwickler ist in der aktuellen Literatur und vielen Online-Ressourcen noch nicht berücksichtigt, muss jedoch beim Compiler-Entwurf berücksichtigt werden.  Ab diesem Zeitpunkt ist ein Wert \glq null\grq{} nur noch möglich, wenn der Entwickler dies bewusst entscheidet, ansonsten benötigen Typen einen Wert.  Mit dieser \glq Null Sicherheit\grq{} werden die Laufzeit-Nullreferenzfehler zu Analysefehlern, die während der lexikalischen Analyse auffallen und somit nicht mehr zwangsläufig zum Absturz der Anwendung führen. \footcite[Vgl.][Abgerufen am \today]{GoogleflutterNullSafty2021} Quelltext \ref{lst:DartNotNullAnymore} visualisiert die Arbeit mit den neuen Datentypen in Dart. 

\lstinputlisting[label={lst:DartNotNullAnymore},caption={[Null-Sicherheit in Dart 2.12]{Null-Sicherheit in Dart 2.x\footcite[In Anlehnung an ][Abgerufen am \today]{GoogleflutterNullSafty2021}}}, language=Dart]{SourceCode/DartNullable.Dart}

Seit \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{GoogleflutterNullSafty2021} dieser Veränderung verhält sich die Programmiersprache Dart analog zu \Csharp auch ein Fragezeichen,  dass für die Definition eines nullable Typs verendet wird ist identisch.  Spezielle Änderungen sind somit nicht mehr durch den Compiler an dieser Stelle vorzunehmen.  

\subsection{Datentypen}
Die Unterscheidung von Referenz und Wertetypen ist elementar für die Programmierung mit \Csharp .  Neben den bereits eingeführten Unterschieden bei der Speicherallokation besteht ein weitere Differenz bei der der Initialisierung.   Während bei Werttypen einfach der entsprechende Wert zugewiesen werden kann,  muss bei Referenztypen expliziert ein Objekt generiert oder ein bestehendes  zugewiesen werden.  Die Erzeugung eines neuen Objekts erfolg  dabei mit dem Operator \glq new\grq .\footcite[Vgl.][S. 93]{Kofler2005} Dart analysiert, wann ein neues Objekt initiiert werden muss und benötigt daher keinen \glq new\grq{} Operator wie in Quelltext \ref{lst:DartNew} dargestellt.  \footcite[Vgl. ][Abgerufen am \today]{GoogleFlutterTour2020} 

\lstinputlisting[label={lst:DartNew},caption={[Objekterzeugung ohne \glq new\grq{} Keyword in Dart]{Objekterzeugung ohne \glq new\grq{} Keyword in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartNew.Dart}

Folgend\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}  ist ein Vergleich der verfügbaren Datentypen in Tabelle  \ref{tab:Datatypes}) veranschaulicht.

\begin{table}[!ht]
\begin{tabularx}{\textwidth}{X|X|X}
   \textbf{Kategorien} & \textbf{\Csharp Datentypen}  &  \textbf{Dart Datentypen}  \\
\hline
	Ganzzahl            			&  sbyte    		& Integer \\ 
										&	byte 			& 	BigInt			\\ 
										&	short 			& 				\\ 
										&	ushort 			& 				\\ 
										&	int 			& 				\\ 
										&	uint 			& 				\\ 
										&	long 			& 				\\ 
										&	ulong 			& 				\\ 
	\hline
	Fließkommazahl         &  double 			& Double \\
										&	float 			& 				\\ 
										&	decimal 			& 				\\ 
	\hline
	Zeichenfolge      					&  String        	& String 					\\ 
	\hline
	Textzeichen      			&  char        	&  					\\ 
	\hline
	Datenfeld      						&  Array        	&  					\\ 
	\hline
	Bool            			& 	bool				& bool \\ 
	\hline
	Auflistung          					& List				& List \\ 
	\hline
	Hashtabelle					& Dictionairy		& Map \\ 
\end{tabularx}
\caption{Gegenüberstellung Datentypen}
 \label{tab:Datatypes}
\end{table}
Die Tabelle zeigt die Datentypen von \Csharp und Dart, es ist ersichtlich, dass sich einige aber nicht alle unterscheiden und für mache Typen in Dart eine entsprechende Repräsentation fehlt.  Auf die für den Compilerbau relevanten Unterschiede wird im folgenden genauer eingegangen. 
\subsubsection{Ganzzahlen}
Wie die Tabelle zeigt,  bietet \Csharp eine Vielzahl von Typen für die Arbeit mit Ganzzahlen.  Diese haben einen Bereich von 8 bis 64 Bit und stehen jeweils mit und ohne Vorzeichen zur Verfügung.  Dart besitzt keine vergleichbar umfangreiche Auswahl von Ganzzahl-Datentypen.  Um Zahlen dennoch effizient im Hauptspeicher abzulegen,wird auf unterschiedliche interne Darstellungen,  je nachdem,  welcher Integer-Wert zur Laufzeit tatsächlich verwendet wird, zurückgegriffen.  Für besonders große Zahlenwerte steht jedoch der DatenTyp \glq Bigint \grq{}  zur Verfügung.  \footcite[Vgl. ][Abgerufen am \today]{Ford2019} Der Compiler muss alle ganzzahligen  \Csharp Datentypen zu Dart \glq Integer\grq,  bis auf \glq long\grq{} und \glq ulong\grq{} die von \glq BigInt\grq{}  repräsentiert werden, übersetzten . 

\subsubsection{Fließkommazahlen}


Fließkommazahlen stellen reelle Zahlen da,  in \Csharp stehen dafür, wie in der Tabelle dargestellt,  verschiedene Datentypen zur Verfügung.  Der \glq decimal\grq{} -Typ behandelt Dezimalstellen am genausten,  während die Alternativen \glq double\grq{} und  \glq float\grq{} nur Annäherungen an bestimmte reelle Zahl darstellen.  \footcite[Vgl. ][Abgerufen am \today]{MicrosoftFlieskomma2021}
In Dart steht für die Arbeit mit Kommazahlen nur der Datentyp \glq  double\grq{} zur Verfügung, \footcite[Vgl. ][Abgerufen am \today]{GoogleDouble} alle Fließkommazahlen müssen daher während der Kompilierung zu \glq double\grq{} umgewandelt werden.

\subsubsection{Textzeichen}

In \Csharp sind einzelne Textzeichen ein \glq  Char\grq, eine Folge von Textzeichen bilden einen  sogenannten \glq  String\grq.  Dart stellt dagegen keinen Datentyp für einzelne Textzeichen zur Verfügung.  Für eine entsprechende Darstellung wird auf den Datentyp \glq  String\grq{} zurückgegriffen.  Die  \glq String\grq{} Klasse verfügt über einen Konstruktor, der einen \glq CharacterCode\grq{} als Übergabewert erwartet und das String Objekt mit einem  Textzeichen erzeugt. Dies wird in Quelltext \ref{lst:DartStringChar} dargestellt.
\lstinputlisting[label={lst:DartStringChar},caption={Erstellung eines Strings mit einem Zeichen in Dart}, language=Dart]{SourceCode/DartNewStringChar.Dart}


\subsubsection{Datenfelder}

Die vielleicht gebräuchlichsten Datensammlungen sind die sogenannten \glq Arrays\grq{} die auch als Datenfelder bezeichnet werden.  Es sind geordnete Gruppen mit einer festen Anzahl von Objekten eines definierten Typs. \footcite[Vgl.][S. 110f]{Kühnel2019} In Dart gibt es im Vergleich zu \Csharp keine Datenfelder alternativ  wird der Datentyp \glq List\grq{}  verwendet,  sodass bei einer Übersetzung von \Csharp eine Anpassung der Datenfelder erfolgen muss.  Die Arbeit mit Datenfeldern in Dart wird in Quelltext \ref{lst:DartList} dargestellt.
\lstinputlisting[label={lst:DartList},caption={Datenfelder in Dart}, language=Dart]{SourceCode/DartList.Dart}


\subsubsection{Auflistungen}
Anders als die \glq Arrays\grq{}  sind die Auflistungen in \Csharp nicht statisch und kontinuierlich sondern dynamisch, was das Einfügen von Elementen vereinfacht.   Diese werden von dem Datentyp \glq List\grq{} repräsentiert,  wie es auch Dart macht.  Der Datentyp \glq List\grq{}  wird in Dart folglich sowohl für Datenfelder,  als auch für Auflistungen verwendet.

\subsubsection{Hashtabellen}

Eine Hashtabelle ist ein Objekt, das Schlüssel und Werte miteinander verknüpft. Sowohl Schlüssel als auch Werte können beliebige Objekttypen sein.  Jeder Schlüssel darf in einer Hashtabelle nur einmal vorkommen und ist unveränderlich während Werte mehrfach verwendet werden können.  
\Csharp ermöglicht die Arbeit mit Hashtabellen mit dem Typ Dictionary,  und Dart durch Map.\footcite[Vgl. ][Abgerufen am \today]{GoogleFlutterTour2020} Im Rahmen der Übersetzung muss der Typ Dictionary folglich durch Map ersetzt werden.  Der folgende Quelltext zeigt die Verwendung einer Hashtabelle in der Programmiersprache Dart.
\lstinputlisting[label={lst:DartHashmap},caption={Hashtabellen in Dart}, language=Dart]{SourceCode/DartHashmap.Dart}


\subsection{Modifizierer}

Alle Klassen und Eigenschaften verfügen in beiden Sprachen über eine Zugriffsebene,  die steuert, ob  Objekte von anderem Code verwendet werden können.  Dabei wird in \Csharp  mithilfe der Schlüsselwörter  public,  private,  protected,  internal,  protected internal,  private protected der Zugriff geregelt.  In Dart gibt es keine Schlüsselwörter, stattdessen wird mit einem Unterstrich (\_) geregelt das kein Zugriff gestattet ist.  Im Gegensatz zu \Csharp wird der Zugriff nicht vor dem Datentypen, sondern als Prefix vor dem Membernamen geführt.  Dies wird in Quelltext \ref{lst:PrivatePublicDart}  dargestellt. 

\lstinputlisting[label={lst:PrivatePublicDart},caption={[Private und Public Definitionen in Dart]{Private und Public Definitionen in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/PrivateDefinition.Dart}

Da  \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} Unterstriche erlaubte Zeichen bei der Entwicklung von  \Csharp -Klassen sind,  müssen sie bei der Übersetzung entfernt werden,  da diese ansonsten zu fehlerhaften Übersetzungen führen könnten.  Durch das Fehlen der anderen oben erwähnten Modifizierer können Berechtigungen in Dart nicht so feingranular definiert werden wie in \Csharp .  Der vom Compiler generierte Dart-Quelltext darf nicht mehr Zugriffe verweigern als der ursprüngliche Quelltext,  daher kann es passieren das der Dart Quelltext weniger gute Restriktionen aufweist.  Dabei fällt auf, dass der Zugriffsmodifizierer nicht mehr vor dem Typen steht sondern als Prefix vor dem Namen der jeweiligen Eigenschaft. 
\subsection{Vererbung}

Erweiterungen oder Veränderung von Klassen entstehen durch die Vererbung, wobei aus einer bestehenden Basisklasse neue abgeleitete Klassen entwickelt werden können, die der Spezialisierung dienen. \footcite[Vgl.  ][Abgerufen am \today]{MicrosoftVeerbung2020}  Der folgende Quelltext zeigt eine Vererebung ist in Dart.

\lstinputlisting[label={lst:DartInherit},caption={[Vererbung in Dart]{Vererbung in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}},  language=Dart]{SourceCode/DartInherit.Dart}
Einer\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}  abgeleiteten Klasse kann exakt nur eine Basisklasse,  Elternklasse zugeordnet werden, dies ist bei \Csharp und Dart gleich definiert. Eine Mehrfachvererbung ist in \Csharp auf Klassenebene nicht vorgesehen, kann aber durch Schnittstellenvererbung erfolgen. Dafür muss eine Implementierung von Attributen oder Methoden über Schnittstelle erfolgen.\footcite[Vgl.][S. 258f.]{Kühnel2019} Dart kennt im Gegensatz zu \Csharp keine Schnittstellen,  sondern verwendet stattdessen das Konzept der Mixins.  Auch hier hat jede Klasse genau eine Elternklasse,  jedoch kann ein Klassenkörper in mehreren Hierarchien vorkommen.  Dies wird in Quelltext \ref{lst:DartMixin} visualisiert. 


\lstinputlisting[label={lst:DartMixin},caption={[Mixin's in Dart]{Mixin's in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartMixin.Dart}

\subsection{Übersetzungsbeispiel}
Durch die \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} herausgearbeiteten Unterschiede in der Klassenmodellierung kann exemplarisch eine  \Csharp Klasse zu Dart übersetzt werden um einen Eindruck über die Arbeitsweise des Compilers zu erlangen.  Der folgende Quelltext veranschaulicht die Ausgangsklasse. 

\lstinputlisting[inputencoding=latin1,label={lst:CshClass},caption={Beispielklasse in C\#},  language=csh]{SourceCode/ExampleClass.cs}

Dieser Quelltext kann nun zu Dart kompiliert werden wie der folgende Code-Ausschnitt demonstriert. 


\lstinputlisting[label={lst:ExampleClassDart},caption={Beispielklasse in Dart}, language=Dart]{SourceCode/ExampleClass.dart}

\section{Namespaces}

Namespaces werden häufig in \Csharp -Programmen verwendet um Klassen zu organisieren. Die meisten Klassen beginnen mit einem Abschnitt von using-Anweisungen,  der die Namensräume einbindet.  Dadurch können Entwicklern auf enthaltene Methoden und Klassen zugreifen ohne den  vollqualifizierten Namen verwenden zu müssen.\footcite[Vgl. ][Abgerufen am \today]{MicrosoftNamespaces2020} 

Dart hat keine Namespaces,  stattdessen werden Pakete und Dateien direkt importiert.  Somit kann ein direkter Zugriff auf alle Klassen und Funktionen innerhalb der Datei gewährt werden.  Im Falle von  Namenskonflikten, z.B.  gleiche Klassennamen,  können Dateien benannt werden.  Quelltext \ref{lst:DartPackages} zeigt die Arbeit mit Paketen und Dateien in Dart.

\lstinputlisting[label={lst:DartPackages},caption={[Importieren von Paketen in Dart]{Importieren von Paketen in Dart\footcite[[In Anlehnung an ][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartPackages.Dart}

\section{Generische Typen}
Durch Generics \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}
 können in .NET Typen als Parameter übergeben werden.   Dadurch lassen sich Klassen und Methoden designen,  bei denen ein Typ durch Abstraktion verzögert übermittelt wird.   So kann ein generischen Typparameter eingesetzt werden um eine Klasse zu entwickeln, die von unterschiedlichen Methoden  verwendet wird,  ohne dass Kosten und Risiken durch die Umwandlungen zur Laufzeit anfallen.\footcite[Vgl. ][Abgerufen am \today]{MicrosoftGenerics2015} 

Generics werden in Dart sehr ähnlich behandelt wie in \Csharp nur das keine Type-Beschränkung übergeben werden muss.  \footcite[Vgl.][S. 98]{Cheng2019} Quelltext \ref{lst:DartGeneric} zeigt die Implementation einer generischen State-Klasse in Dart. 

\lstinputlisting[label={lst:DartGeneric}, caption={[Generics in Dart]{Generics in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartGeneric.Dart}
\section{Delegaten}

In .Net\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} ist ein Delegate ein Typ,  der Verweise auf Methoden mit einer bestimmten Parameterliste und dem Rückgabetyp darstellt.  Nach der Instanziierung eines Delegaten können die Instanz mit einer beliebigen Methode verknüpft werden,  die eine kompatible Signatur und einen kompatiblen Rückgabetyp aufweisen.  Diese können die Methode über die Delegatinstanz aufrufen.  Delegates werden dazu verwendet,  um Methoden als Argumente an anderen Methoden zu übergeben.  Da Ereignishandler ebenfalls Methoden sind können diese durch Delegates aufgerufen werden.  Benutzerdefinierte Methoden können also durch Steuerelemente diese Methode aufrufen, wenn ein bestimmes Ereignis wie ein klick auf einen Button eintritt.\footcite[Vgl. ][Abgerufen am \today]{MicrosoftDelegates2015} 

In Dart kann der Typ Typedef verwendet werden, um eine Methodensignatur zu definieren und eine Instanz davon in einer Variablen zu halten. \footcite[Vgl. ][Abgerufen am \today]{Pedley2019}  Dies wird in Quelltext \ref{lst:DartDelegates} dargestellt. 


\lstinputlisting[label={lst:DartDelegates},  caption={[Delegates in Dart]{Delegates in Dart\footcite[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartDelegates.Dart}


\section{Bibliotheken}

Klassenbibliotheken\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} sind das Konzept der freigegebenen Bibliothek für .NET.  Somit können  nützliche Funktionalität auf Module verteilt werden,  die von mehreren Anwendungen verwendet werden können. Sie können auch verwendet werden, um Funktionalität zu laden, die beim Start der Anwendung nicht benötigt wird bzw. nicht bekannt ist.\footcite[Vgl. ][Abgerufen am \today]{MicrosoftClassLibary2016} 

Dart verfügt über eine Vielzahl von Kernbibliotheken, die für viele alltägliche Programmieraufgaben wie das Arbeiten mit Objektsammlungen,  das Durchführen von Berechnungen und das Kodieren/Dekodieren von Daten  unerlässlich sind.  Zusätzliche APIs sind in von der Community bereitgestellten Paketen verfügbar die bereits im letzten Kapitel erwähnt wurden. Dieses Konzept ist dem aus .NET bekannten Bilbiothek Konzept sehr ähnlich.
Neben den Konzept sind auch die Inhalte in einigen Bibliotheken sehr ähnlich. So ähnelt die Bibliothek dart:async sehr dem .Net Namespace System.Threading.  Außerdem ist dart:Math sehr ähnlich wie System.MAth und dart.io zu System.IO.
Darüber hinaus können Funktionen direkt Inhalt von  Dateien sein, ohne eine Klasse oder einen Namespace.  

\section{Asynchrone Benutzeroberfläche und Parallelität}

Das aufgabenbasierte asynchrone Programmiermodell stellt eine Abstraktion über asynchronen Code bereit. Der Quelltext kann dabei in gewohnter Weise als eine Folge von Anweisungen geschrieben werden und auch so gelesen werden, als ob jede Anweisung abgeschlossen wäre, bevor die nächste Anweisung beginnt. Der Compiler führt eine Reihe von Transformationen durch, da möglicherweise einige dieser Anweisungen gestartet werden und eine Task zurückgeben, die die derzeit ausgeführte Arbeit darstellt.
Ziel dieser Syntax ist es: Code zu aktivieren, der sich wie eine Folge von Anweisungen liest, aber in einer deutlich komplizierteren Reihenfolge ausgeführt wird, die auf einer externen Ressourcenzuordnung und dem Abschluss von Aufgaben basiert. Vergleichbar ist dies mit der Art und Weise, wie Menschen Anweisungen für Prozesse erteilen, die asynchrone Aufgaben enthalten.  \footcite[Vgl. ][Abgerufen am \today]{MicrosoftAsyncAwait2020} 

Die Verwendung von asychronen Methoden für lang laufende Aufgaben, wie das herunterladen von Daten, trägt dazu bei, dass die Benutzeroberfläche reaktionsfähig bleibt , während die Nichtverwendung dieser Methoden oder die unsachgemäße Verwendung dazu führen kann,  dass die Benutzeroberfläche Ihrer App nicht mehr auf Benutzereingaben reagiert, bis die lang laufende Aufgabe abgeschlossen ist.  Für beide in dieser Arbeit behandelten Frameworks gilt,  dass arbeitsaufwendige Aufgaben nicht auf in dem Thread durchgeführt werden sollten,  die für die Benutzeroberfläche zuständig ist, um ein einfrieren dieser zu verhindern. 
In Flutter werden die asynchronen Möglichkeiten, die die Sprache Dart bietet, auch \glq async\grq{} und \glq await\grq{}  genannt, um asynchrone Arbeiten auszuführen. Dies ist dem Vorgehen in \Csharp sehr ähnlich und ist der Lösung in Xamarin.Forms sehr ähnlich die ebenfalls die Schlüsselwörter  \glq async\grq{} und \glq await\grq{}  verwendet. 

\lstinputlisting[label={lst:DartAsync},caption={[Async und Await in Dart]{Async und Await in Dart\footcite[[In Anlehnung an ][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartAsyncAwait.Dart}

Um\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}  die Vorteile von mehreren Prozessorkernen nutzen zu können,  reicht dieses Konzept jedoch nicht aus,  in Flutter müssen potentielle Hintergrund-Thread manuell verwaltet werden,  ähnlich wie bei \glq async\grq{} und \glq await\grq{}  ist das vorgehen vergleichbar mit dem Vorgehen in \Csharp. So steht für den Start von rechenintensive Arbeiten sogenannte \glq Isolate\grq{} zur Verfügung,   dies ähnlich arbeiten wie Tasks in \Csharp. Dabei sind \glq Isolates \grq{}  sind separate Ausführungsthreads, die sich keinen Speicher mit dem Hauptspeicherheap der Ausführung teilen.  Dies ist ein Unterschied zu \glq Tasks\grq{} .  Das bedeutet, dass  vom Haupt-Thread aus nicht auf Variablen zugegriffen werden kann oder Ihre Benutzeroberfläche durch den Aufruf von \glq IsetState()\grq{}  aktualisieren können.

\section{Netzwerkaufrufe}
Um Netzwerkaufrufe durchzuführen, um Daten von einem Server abzurufen oder Benutzereingaben des Anwenders zu übermittelt wird in Xamarin.Forms die Klasse HttpClient verwenden. Für die Arbeit in Flutter wird dafür das http-Paket verwendet, welches von einem großteil der Netzwerkfunktionalitäten abstrahiert und es einfach macht Netzwerkaufrufe zu tätigten.  Um eine Netzwerkanfrage zu stellen ist es wichtig, die vorher eingeführten Schlüsselwörter \glq async\grq{} und \glq await\grq{} zu verwenden, damit die Benutzeroberfläche auch während der Anfrage Reaktionsfähig bleibt.  Ein Netzwerkanfrage in Flutter wird in  \ref{lst:FlutterNetworkRequest} dargestellt.


\lstinputlisting[label={lst:FlutterNetworkRequest},caption={Flutter Network request}, language=Dart]{SourceCode/NetworkRequest.Dart}
\footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} 


\section{Ereignisse}
Ein \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019} Ereignis ist eine Meldung, die von einem Objekt gesendet wird, um das Auftreten einer Aktion zu signalisieren.  In dem vorherigen Kapitel wurde schon eingeführt, dass Xamarin.Forms ein ereignisgesteuertes Framework ist, welches Ereignisse wie den Klick auf eine Schaltfläche nutzen um Aktionen auszulösen.  Events können in \Csharp auch ohne \ac{xaml}-Dateien verwendet werden beispielsweise wenn eine  Programmlogik, z. B. das Ändern eines Eigenschaftswerts, ausgelöst. Das Objekt, von dem das Ereignis ausgelöst wird, wird als Ereignissender bezeichnet.  Dem Ereignissender ist nicht bekannt, welches Objekt oder welche Methode die ausgelösten Ereignisse empfangen (behandeln) wird.  Das Ereignis ist in der Regel ein Member des Ereignissenders.  Beispielsweise ist das Click-Ereignis ein Member der Klasse Button, und das PropertyChanged-Ereignis ist ein Member der Klasse, von der die INotifyPropertyChanged-Schnittstelle implementiert wird. \footcite[Vgl. ][Abgerufen am \today]{MicrosoftEvents2017} 

Anstelle von Ereignisse werden in Dart sogenannte Streams verwendet, die ähnlich wie Ereignisse arbeiten. Anstelle eines Ereignisses in \Csharp mit Delegaten, die dann alle aufgerufen werden, wenn ein Ereignis ausgelöst wird, arbeitet Dart in Streams.  Ein Stream ist ähnlich wie ein Ereignis,  für den start werden sie geöffnet, danach abgheört und zum Ende hin geschlossen..  Der Vorteil dieses Ansatzes ist, dass dabei Werte transformiert oder Ereignisse für eine bestimmte Zeitspanne anhalten und vieles mehr. 

\lstinputlisting[label={lst:DartEvents},caption={[Events in Dart]{Events in Dart\footcite[[In Anlehnung an ][Abgerufen am \today]{Pedley2019}}}, language=Dart]{SourceCode/DartEvents.Dart}
 \footcitetext[Quelltext in Anlehnung an][Abgerufen am \today]{Pedley2019}


