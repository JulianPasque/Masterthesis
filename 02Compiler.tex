\chapter{Compiler}

%\section{Grundlagen}
Programmiersprachen dienen als Verständigungsmittel zwischen Programmierern und Rechenanlagen. Je mehr sich diese Sprachen der Terminologie eines bestimmtes Anwendungsgebietes nähern, desto besser eignen sie sich zur Dokumentation von Algorithmen und Anwendungen. Jedoch entfernen sich diese Sprachen weiter von den Gegebenheiten des realen Rechners. Dieser Effekt muss vor der Ausführung eines Programmes wieder umgekehrt werden, daher das in einer problemorientierten Programmiersprache geschriebene Programm muss in eine maschinenorientierte Form überführt werden.\footcite[Vgl.][S. 15]{Schneider1975} Bereits im Jahre 1951 stelle Rutishauser fest, dass Rechner in der Lage sind diesen Übersetzungsvorgang selbst durchzuführen.\footcite[Vgl.][S. 1]{Quelle fehlt! improve https://link.springer.com/article/10.1007/BF02009622}  %Hier fehlt die Quelle!
\\
Der Bedarf an dieser automatischen Übersetzung hat sich historisch durch die Verwendung von Hochsprachen ergeben. Da diese statt Anwendungen aus maschinennahen Instruktionen aufzubauen menschenfreundliche Sprachelemente verwenden. \footcite[Vgl.][S. 47]{Wagenknecht2014}
Durch diesen Bedarf wurden in 50er Jahren des 20 Jahrhunderts die ersten Compiler entwickelt, welche es erlaubten, dass Programmierer Sprachen verwenden konnten die neben der Problemlösung auch Dokumentationszwecken dienen konnten. \footcite[Vgl.][S. 1]{Quelle fehlt! Meilensteine der Rechentechnik: Zur Geschichte der Mathematik und der Informatik}  %Hier fehlt die Quelle!\\
\\
Diese historische Einführung zeigt, dass Compiler schon eine lange Zeit existieren und sich in der Wissenschaft eine einheitliche Definition für diese ergeben hat. So beschreibt \citeauthor{Ullmann2008} im Jahre \citeyear{Ullmann2008} Compiler wie folgt:\footcite[Vgl.][S. 1]{Ullmann2008} 
\begin{Def}[Compiler]
Ein Compiler ist ein Programm, welches ein anderes Programm aus einer Quellsprache in ein gleichwertiges Programm einer Zielsprache übersetzen kann.
\end{Def}
Neben dem Compiler können noch andere Programme Aufgaben für die Sprachverarbeitung übernehmen, diese sollen an dieser Stelle ebenfalls eingeführt werden:\footcite[Vgl.][S. 4f]{Ullmann2008} \\\begin{itemize}
\setlength\itemsep{-1.5em}
\item Präprozessor: Ein Quellprogramm kann aus mehreren Modulen gegSliedert sein, welche in anderen Dateien gespeichert sind. Die Aufgabe des Präprozessor ist es, diese Dateien zusammenzustellen. 
\item Assembler: Compiler können die Sprache Assembler als Zielsprache haben, da sich solche Programme leichter auf Fehler untersuchen lassen. Der Assembler übernimmt die Verarbeitung und gibt den entsprechenden Maschinencode aus.
\item Linker: Da Umfangreiche Programme häufig in mehreren Teilen kompiliert werden müssen die einzelnen Elemente miteinander verknüpft werden, Der Linker übernimmt diese Aufgaben indem er externe Speicheradressen auflöst.
\end{itemize}
\section{Aufgabe}
Die Aufgaben des Compilers lassen sich, mit dem Ziel der Übersetzung von Programmiersprachen, in die zwei Unteraufgaben Analyse und Synthese unterteilen. \footcite[Vgl.][S. 6]{Ullmann2008}\\
Bei der Analyse wird das Programm in seine Bestandteile zerlegt und mit einer grammatischen Struktur versehen. Diese wird anschließend verwendet um eine Zwischendarstellung des Quellprogramms zu erstellen. Dabei wird überprüft, ob das Programm syntaktisch oder semantisch nicht wohlgeformt ist, und ob der Programmierer Änderungen vornehmen muss. Außerdem werden bei der Analyse Informationen über das Quellprogramm gesammelt und in einer so genannten Symboltabelle abgelegt.  \footcite[Vgl.][S. 6f]{Ullmann2008}\\
Bei der Synthese wird aus der Zwischendarstellung un den Informationen aus der Symboltabelle das gewünschte Zielprogramm konstruiert. Der Teil des Compilers, der sich mit der Analyse befasst wird oft als Front-End bezeichnet, derjenige der für die Synthese zustädnig ist als Back-End.  \footcite[Vgl.][S. 7]{Ullmann2008}
\section{Phasen}
Der Vorgang des Kompilieren lässt sich nach \citeauthor{Ullmann2008} in mehere Phasen unterteilen, die an dieser Stelle eingeführt werden sollen. \footcite[Vgl.][S. 6]{Ullmann2008}
\subsection{Lexikalische Analyse}
Die erste Phase eines Compilers ist die sogenannte lexikalische Analyse. Dabei wird der Zeichenstream, der das Quellprogramm bildet in Lexeme gegliedert. Für jedes erzeugte Lexem gibt der lexikalische analysator ein Token in folgender Form aus:\footcite[Vgl.][S. 7f]{Ullmann2008}
\begin{center}
 <Name, Attributwert>
\end{center}
Der Name ist dabei ein abstaktes Symbol, das während der nächste Phase, der Syntaxanalyse verwendet wird. Der Attributwert auf einen Eintrag in der symboltabelle für dieses Token zeigt. Diese Informationen werden in den späteren Phasen für die semantische Analyse und die Codegeneriung benötigt. \footcite[Vgl.][S. 7f]{Ullmann2008}
\subsection{Syntaxanalyse}
Die zweite Phase des Compilers ist die Syntaxanalye. Dafür verwendet der sogenannte Parser die vom lexikalischen Analysator ausgegebenen Token um eine baumartige Zwischendarstellung zu erstellen. die die grammatische Struktur der Tokens zeigt. Die Darstellung wird daher auch häufig als Syntaxbaum bezeichnet. Die Knoten stehen dabei für eine Operation und seine Kindknoten für die Argumente dieser Operation. Die Anordnung er Operationen stimmt mit üblichen arithmentischen Konventionen überein, wie zum Beispiel der vorrang der Multiplikation vor Addition. \footcite[Vgl.][S. 9]{Ullmann2008}
\subsection{Semantische Analyse}
Bei der semantischen Analyse wird der Syntaxbaum und die Informationen aus der Symboltabelle verwendet um das Quellprogramm auf semantische Konsistenz mit der Sprachdefinition zu überprüfen. Außerdem werden in dieser Typinformationen gesammelt und entweder im Syntaxbaum oder in der Symboltabelle hinterlegt um sie in späteren Phasen zu verwenden. Dabei werden außerdem Typen überprüft, daher analysiert ob jeder Operator die passenden Operanden hat. \footcite[Vgl.][S. 9ff]{Ullmann2008}
\subsection{Zwischencodeerzeugung}
Bei der Übersetzung eines Quellprogramms in den Zielcode kann der Compiler mehrere Zwischendarstellungen in verschiedenen Formen erstellen. Syntaxbäume sind beispielsweise eine solche Darstellung. Nach der semantischen Analyse stellen viele Compiler eine maschinennahe Zwischendarstellung die für eine Abstrakte Maschine entworfen wurden.  \footcite[Vgl.][S. 11]{Ullmann2008}
\subsection{Codeoptimierung}
In dieser Phase wird der maschinenunabhängige Code so optimiert, dass sich darauf ein besserer Zielcode ergibt. Dabei bedeutet besser, schnellerer code oder code der weniger Ressourcen verbraucht. Der Umfang der Codeoptimierung schwankt dabei von Compiler zu Compiler erheblich.  \footcite[Vgl.][S. 11f]{Ullmann2008}
\subsection{Codeerzeugung}
Bei der Codeerzegung werden die Eingaben aus der Zwischendarstellung des Quellprogramms entgegengenommen und auf die Zielsprache abgebildet. Ein entsheidender Aspekt der Codeerzeugung ist die sinnvolle zuweisung von Registern für Variablen, falls es sich bei der Zielsprache um Maschinencode handelt.\footcite[Vgl.][S. 13]{Ullmann2008}

\section{Rekursiver Ansatz}